// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package processor

import (
	"encoding/binary"

	"github.com/nolag/gocpu/memory"
	"github.com/nolag/gocpu/registers"
)

// FixedInstructionLenRunnerUint8 runs uint8 instructions one at a time, by calling InstructionRunnerUint8.
type FixedInstructionLenRunnerUint8 struct {
	memory.Memory
	binary.ByteOrder
	InstructionRunnerUint8
	Pc                        registers.ProgramCounter
	MemoryReadFailureCallback ErrorCallback
}

// Step runs the next instruction, returns error to indicate an unhandeled exception
func (cpu *FixedInstructionLenRunnerUint8) Step() error {
	i := instructionUint8(0)
	val, err := memory.ReadUint8(cpu.Memory, cpu.ByteOrder, cpu.Pc.ReadAsPc())

	if err != nil {
		callback := cpu.MemoryReadFailureCallback
		if callback != nil {
			err = cpu.MemoryReadFailureCallback(err)
		}

		return err
	}

	err = cpu.RunUint8(val)
	if err == nil {
		cpu.Pc.InrementAsPc(i.size())
	}

	return err
}

// FixedInstructionLenRunnerUint16 runs uint16 instructions one at a time, by calling InstructionRunnerUint16.
type FixedInstructionLenRunnerUint16 struct {
	memory.Memory
	binary.ByteOrder
	InstructionRunnerUint16
	Pc                        registers.ProgramCounter
	MemoryReadFailureCallback ErrorCallback
}

// Step runs the next instruction, returns error to indicate an unhandeled exception
func (cpu *FixedInstructionLenRunnerUint16) Step() error {
	i := instructionUint16(0)
	val, err := memory.ReadUint16(cpu.Memory, cpu.ByteOrder, cpu.Pc.ReadAsPc())

	if err != nil {
		callback := cpu.MemoryReadFailureCallback
		if callback != nil {
			err = cpu.MemoryReadFailureCallback(err)
		}

		return err
	}

	err = cpu.RunUint16(val)
	if err == nil {
		cpu.Pc.InrementAsPc(i.size())
	}

	return err
}

// FixedInstructionLenRunnerUint32 runs uint32 instructions one at a time, by calling InstructionRunnerUint32.
type FixedInstructionLenRunnerUint32 struct {
	memory.Memory
	binary.ByteOrder
	InstructionRunnerUint32
	Pc                        registers.ProgramCounter
	MemoryReadFailureCallback ErrorCallback
}

// Step runs the next instruction, returns error to indicate an unhandeled exception
func (cpu *FixedInstructionLenRunnerUint32) Step() error {
	i := instructionUint32(0)
	val, err := memory.ReadUint32(cpu.Memory, cpu.ByteOrder, cpu.Pc.ReadAsPc())

	if err != nil {
		callback := cpu.MemoryReadFailureCallback
		if callback != nil {
			err = cpu.MemoryReadFailureCallback(err)
		}

		return err
	}

	err = cpu.RunUint32(val)
	if err == nil {
		cpu.Pc.InrementAsPc(i.size())
	}

	return err
}

// FixedInstructionLenRunnerUint64 runs uint64 instructions one at a time, by calling InstructionRunnerUint64.
type FixedInstructionLenRunnerUint64 struct {
	memory.Memory
	binary.ByteOrder
	InstructionRunnerUint64
	Pc                        registers.ProgramCounter
	MemoryReadFailureCallback ErrorCallback
}

// Step runs the next instruction, returns error to indicate an unhandeled exception
func (cpu *FixedInstructionLenRunnerUint64) Step() error {
	i := instructionUint64(0)
	val, err := memory.ReadUint64(cpu.Memory, cpu.ByteOrder, cpu.Pc.ReadAsPc())

	if err != nil {
		callback := cpu.MemoryReadFailureCallback
		if callback != nil {
			err = cpu.MemoryReadFailureCallback(err)
		}

		return err
	}

	err = cpu.RunUint64(val)
	if err == nil {
		cpu.Pc.InrementAsPc(i.size())
	}

	return err
}
