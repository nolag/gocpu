// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package processor

import "encoding/binary"
import "github.com/nolag/gocpu/memory"

// FixedInstructionLenPcUint8RunnerUint16 runs a sinlge 32 bit instruction one at a time, by calling InstructionRunner32.
type FixedInstructionLenPcUint8RunnerUint16 struct {
	memory.Memory
	binary.ByteOrder
	InstructionRunnerUint16
	Pc                        uint8
	MemoryReadFailureCallback ErrorCallback
}

// Step runs the next instruction, returns error to indicate an unhandeled exception
func (cpu *FixedInstructionLenPcUint8RunnerUint16) Step() error {
	i := instructionuint16(0)
	val, err := memory.ReadUint16(cpu.Memory, cpu.ByteOrder, uint64(cpu.Pc))

	if err != nil {
		callback := cpu.MemoryReadFailureCallback
		if callback != nil {
			err = cpu.MemoryReadFailureCallback(err)
		}

		return err
	}
	cpu.Pc += uint8(i.size())
	cpu.RunUint16(val)
	return nil
}

// FixedInstructionLenPcUint16RunnerUint16 runs a sinlge 32 bit instruction one at a time, by calling InstructionRunner32.
type FixedInstructionLenPcUint16RunnerUint16 struct {
	memory.Memory
	binary.ByteOrder
	InstructionRunnerUint16
	Pc                        uint16
	MemoryReadFailureCallback ErrorCallback
}

// Step runs the next instruction, returns error to indicate an unhandeled exception
func (cpu *FixedInstructionLenPcUint16RunnerUint16) Step() error {
	i := instructionuint16(0)
	val, err := memory.ReadUint16(cpu.Memory, cpu.ByteOrder, uint64(cpu.Pc))

	if err != nil {
		callback := cpu.MemoryReadFailureCallback
		if callback != nil {
			err = cpu.MemoryReadFailureCallback(err)
		}

		return err
	}
	cpu.Pc += uint16(i.size())
	cpu.RunUint16(val)
	return nil
}

// FixedInstructionLenPcUint32RunnerUint16 runs a sinlge 32 bit instruction one at a time, by calling InstructionRunner32.
type FixedInstructionLenPcUint32RunnerUint16 struct {
	memory.Memory
	binary.ByteOrder
	InstructionRunnerUint16
	Pc                        uint32
	MemoryReadFailureCallback ErrorCallback
}

// Step runs the next instruction, returns error to indicate an unhandeled exception
func (cpu *FixedInstructionLenPcUint32RunnerUint16) Step() error {
	i := instructionuint16(0)
	val, err := memory.ReadUint16(cpu.Memory, cpu.ByteOrder, uint64(cpu.Pc))

	if err != nil {
		callback := cpu.MemoryReadFailureCallback
		if callback != nil {
			err = cpu.MemoryReadFailureCallback(err)
		}

		return err
	}
	cpu.Pc += uint32(i.size())
	cpu.RunUint16(val)
	return nil
}

// FixedInstructionLenPcUint64RunnerUint16 runs a sinlge 32 bit instruction one at a time, by calling InstructionRunner32.
type FixedInstructionLenPcUint64RunnerUint16 struct {
	memory.Memory
	binary.ByteOrder
	InstructionRunnerUint16
	Pc                        uint64
	MemoryReadFailureCallback ErrorCallback
}

// Step runs the next instruction, returns error to indicate an unhandeled exception
func (cpu *FixedInstructionLenPcUint64RunnerUint16) Step() error {
	i := instructionuint16(0)
	val, err := memory.ReadUint16(cpu.Memory, cpu.ByteOrder, uint64(cpu.Pc))

	if err != nil {
		callback := cpu.MemoryReadFailureCallback
		if callback != nil {
			err = cpu.MemoryReadFailureCallback(err)
		}

		return err
	}
	cpu.Pc += uint64(i.size())
	cpu.RunUint16(val)
	return nil
}
